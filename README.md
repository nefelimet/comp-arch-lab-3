

# comp-arch-lab-3
Αναφορά και κώδικας για το τρίτο εργαστήριο του μαθήματος Αρχιτεκτονική Προηγμένων Υπολογιστών.

Authors: Δήμου Μαρία, Μεταλλίδου Νεφέλη

### Βήμα 1

#### Ερώτημα 1

Η κύρια εστίαση του McPAT είναι η ακριβής μοντελοποίηση ισχύος και περιοχής σε αρχιτεκτονικό επίπεδο, όταν ο χρονισμός δίνεται ως κύριος περιορισμός σχεδίασης. Τόσο η σχετική όσο και η απόλυτη ακρίβεια είναι σημαντικές για τη μοντελοποίηση ισχύος σε αρχιτεκτονικό επίπεδο. Σχετική ακρίβεια σημαίνει ότι οι αλλαγές στη μοντελοποιημένη ισχύ ως αποτέλεσμα των τροποποιήσεων της αρχιτεκτονικής θα πρέπει να αντικατοπτρίζουν σε σχετική κλίμακα τις αλλαγές που θα βλέπαμε σε μια πραγματική σχεδίαση. Ενώ η σχετική ακρίβεια είναι κρίσιμη, η απόλυτη ακρίβεια είναι επίσης σημαντική εάν κάποιος θέλει να συγκρίνει τα αποτελέσματα με τα όρια θερμικής ισχύος σχεδιασμού (TDP) ή να τοποθετήσει την εξοικονόμηση ισχύος στον πυρήνα στο πλαίσιο ολόκληρου του επεξεργαστή ή ολόκληρου του συστήματος. Η σχετική ακρίβεια του McPAT διασφαλίζει ότι τα σχετικά βάρη ισχύος των διαφόρων εξαρτημάτων ενός τσιπ έχουν μοντελοποιηθεί σωστά. Η απόλυτη ακρίβεια μεγέθους του McPAT σημαίνει ότι οι αριθμοί ισχύος για τα επιμέρους στοιχεία και η συνολική ισχύς αξιολογούνται σωστά.
Για την επικύρωση του εργαλείου, τα αποτελέσματά του έχουν συγκριθεί με τα δημοσιευμένα αποτελέσματα για συγκεκριμένους επεξεργαστές. Γενικά τα αποτελέσματα του McPAT είναι πολύ κοντά στις πραγματικές τιμές, γι' αυτό και θεωρείται αξιόπιστο εργαλείο μοντελοποίησης.

Οι επεξεργαστές που είχαν χρησιμοποιηθεί ήταν οι εξής :
* Niagara (90nm, 1.2GHz, 1.2V)
* Niagara2 (65nm, 1.4GHz, 1.1V)
* Xeon (65nm, 3.4GHz, 1.25V)
* Alpha 21364 (180nm, 1.2GHz, 1.5V)

#### Ερώτημα 2
* **Dynamic power**: Τα κυκλώματα καταναλώνουν δυναμική ισχύ όταν φορτίζουν και εκφορτίζουν τα χωρητικά φορτία για να αλλάξουν καταστάσεις. Η δυναμική ισχύς είναι ανάλογη της συνολικής χωρητικότητας του φορτίου, της τάσης τροφοδοσίας, της μεταβολής της τάσης κατά τη διάρκεια της μεταγωγής, της συχνότητας του ρολογιού και του συντελεστή δραστηριότητας. Υπολογίζουμε τη χωρητικότητα φορτίου μιας μονάδας αναλύοντάς την σε βασικά μπλοκ κυκλωμάτων και χρησιμοποιώντας αναλυτικά μοντέλα για κάθε μπλοκ με συσκευές κατάλληλου μεγέθους. Υπολογίζουμε τον παράγοντα δραστηριότητας χρησιμοποιώντας στατιστικά στοιχεία πρόσβασης από την αρχιτεκτονική προσομοίωση μαζί με τις ιδιότητες του κυκλώματος.
* **Short-circuit power**: Υπολογίζουμε την ισχύ βραχυκυκλώματος χρησιμοποιώντας τις εξισώσεις που προκύπτουν από την εργασία των Nose et al. που προβλέπει τις τάσεις για την ισχύ βραχυκυκλώματος. Εάν ο λόγος της τάσης κατωφλίου προς την τάση τροφοδοσίας συρρικνωθεί, η ισχύς βραχυκυκλώματος γίνεται πιο σημαντική. Συνήθως είναι περίπου το 10% της συνολικής δυναμικής ισχύος, ωστόσο σε ορισμένες περιπτώσεις μπορεί να φτάσει και το 25% της δυναμικής ισχύος.
* **Static power**: Η στατική ισχύς καταναλώνεται λόγω του ρεύματος διαρροής μέσω των τρανζίστορ, τα οποία στην πραγματικότητα λειτουργούν ως "ατελείς" διακόπτες.
* **Leakage power**: Το ρεύμα διαρροής εξαρτάται από το πλάτος των τρανζίστορ και την τοπική κατάσταση των διατάξεων. Υπάρχουν δύο μηχανισμοί διαρροής. Η διαρροή κάτω από το κατώφλι εμφανίζεται επειδή ένα μικρό ρεύμα περνάει μεταξύ της πηγής και της αποστράγγισης των τρανζίστορ εκτός κατάστασης. Η διαρροή πύλης είναι το ρεύμα που διαρρέει μέσω του ακροδέκτη πύλης και ποικίλλει σε μεγάλο βαθμό ανάλογα με την κατάσταση της διάταξης. Προσδιορίζουμε το ρεύμα διαρροής της μονάδας χρησιμοποιώντας τα δεδομένα της MASTAR και της Intel.

Όσο πιο μεγάλο χρονικά είναι ένα πρόγραμμα που τρέχει στον επεξεργαστή, τόσο πιο μεγάλη είναι η ισχύς που καταναλώνεται. Δεν υπάρχει μια σταθερή σχέση μεταξύ performance και ισχύος, καθώς τα δεδομένα που υπάρχουν σχετίζονται με συγκεκριμένες αρχιτεκτονικές.
Έχουν υπάρξει προσπάθειες για προγράμματα που μειώνουν την ισχύ, όπως αναδιατάξεις κώδικα για καλύτερη τοπικότητα των τιμών των καταχωρητών (Chang and Pedram 1995), scheduling των VLIW εντολών για μείωση της κατανάλωσης στο instruction bus (Lee et al. 2003) κτλ. 

#### Ερώτημα 3
Σε γενικές γραμμές, όσο μεγαλύτερη ισχύ καταναλώνει ένα εξάρτημα, τόσο πιο γρήγορα εξαντλεί την μπαταρία, άρα δίνει μικρότερη διάρκεια ζωής. Ωστόσο, σημαντικό ρόλο διαδραματίζει και το *energy efficiency*, δηλαδή η ενεργειακή αποδοτικότητα ενός επεξεργαστή. Όσο πιο αποδοτικός είναι ενεργειακά ένας επεξεργαστής, τόσο λιγότερη ενέργεια χρησιμοποιεί για το ίδιο task. Ως μετρική χρησιμοποιείται η απόδοση ανά Watt (*performance per Watt*), το οποίο μπορεί να μετρηθεί σε FLOPS ανά Watt. 
Το McPAT μας δίνει αποτελέσματα για την ισχύ, αλλά δεν μπορεί να μας δώσει αποτελέσματα για το performance ενός επεξεργαστή. Για αυτόν τον σκοπό χρειάζεται ένας performance simulator, όπως το gem5.

#### Ερώτημα 4
Έστω x1 το performance per Watt του Xeon,  p1 το performance του, και w1 η ισχύς του. Αντίστοιχα x2, p2 και w2 για τον A9. Θα ισχύει x1 = p1 / w1 και x2 = p2 / w2.
Γνωρίζουμε ότι για την συγκεκριμένη εφαρμογή το performance του Xeon είναι 40 φορές καλύτερο από του Α9, οπότε p1 = 40 * p2. Για τις ισχείς, θα χρησιμοποιήσουμε το peak power από τα αποτελέσματα που παρήγαγε ο McPAT. Αυτά βρίσκονται στα αρχεία step1/Xeon.txt και step1/ARM_A9_2GHz.txt αντίστοιχα. Οπότε έχουμε w1 = 134.938W, w2 = 1.74189W.
Αντικαθιστώντας, έχουμε: 

x1 = p1 / w1 = 40 * p2 / 134.938

και

x2 = p2 / w2 = p2 / 1.74189

Διαιρώντας τις δύο σχέσεις κατά μέλη έχουμε 

x1 / x2 = 0.516  ή  x2 = 2 * x1.

Οπότε συμπεραίνουμε ότι ο ARM A9 είναι 2 φορές πιο ενεργειακά αποδοτικός από τον Xeon. 
Αυτό είναι κάτι που περιμέναμε, καθώς ο Xeon είναι high performance επεξεργαστής (οπότε δεν δίνει έμφαση στην ισχύ), ενώ ο Α9 χρησιμοποιείται κυρίως σε ενσωματωμένα συστήματα (οπότε δίνει έμφαση στην ενεργειακή αποδοτικότητα).

### Βήμα 2

#### Ερώτημα 1
Για την συμβατότητα του output του GEM5 με το input του McPAT, χρησιμοποιείται το script *GEM5ToMcPAT . py* . Χρησιμοποιώντας και το [TAKEKYA/gem5tomcpat](https://github.com/TAKAKEYA/gem5tomcpat) GitHub repo, βλέπουμε ότι στο xml αρχείο πρέπει να αλλάξουμε τις παραμέτρους σύμφωνα με το πώς υπάρχουν στο *stats.txt* και στο *config.json*. Λόγω παλιάς έκδοσης του McPAT, χρησιμοποιεί τις μετβαλητές *system.cpu* αντί για *system.cpu_cluster.cpus* που χρησιμοποιεί το GEM5. Οπότε χρειάστηκε να αλλάξουμε αυτά αλλά και κάποια άλλα ονόματα μεταβλητών (*system.l2* -> *system.cpu_cluster.l2*, *system.mem_ctrls* -> *system.mem_ctrls0*) στο *stats.txt* και στο *config.json*. Ωστόσο, κάποιες μεταβλητές στο xml δεν υπήρχαν καθόλου στα *stats.txt* και *config.json*, όπως το *stats.system.mem_ctrls0.mem_writes::total*. Οπότε το τελικό script δεν μπόρεσε να τρέξει σωστά.
Ανοίγοντας το αρχείο *GEM5ToMcPAT . py*, στην γραμμή 38 βλέπουμε το usage. Η εντολή που χρησιμοποιούμε για να το τρέξουμε είναι (μέσα στον φάκελο Scripts):

	 $ python GEM5ToMcPAT.py "../../stats.txt" "../../config.json" "../mcpat/ProcessorDecriptionFiles/ARM_A9_2GHz.xml"
	 
 Τρέχοντας αυτήν την εντολή, δημιουργείται στον φάκελο ένα αρχείο με το όνομα *mcpat-out.xml*. Τρέξαμε την εντολή για το *ARM_A9_2GHz.xml* αντί για το *inorder_arm.xml*.

 Για το μέγεθος *area*, το βρίσκουμε απ'το output του McPAT.
 
 Για το *delay* στο αρχείο *stats.txt* βρίσκουμε τις εξής παραμέτρους:
 * *system.membus.pwrStateResidencyTicks*
 * *system.mem_ctrls0.pwrStateResidencyTicks*
 * *system.mem_ctrls1.pwrStateResidencyTicks*
 * *system.cpu_cluster.toL2Bus.pwrStateResidencyTicks*
 * *system.cpu_cluster.l2.pwrStateResidencyTicks*
 * *system.cpu_cluster.l2.tags.pwrStateResidencyTicks*
 * *system.cpu_cluster.cpus.pwrStateResidencyTicks*
 * *system.cpu_cluster.cpus.icache.pwrStateResidencyTicks*
 * *system.cpu_cluster.cpus.icache.tags.pwrStateResidencyTicks*
 * *system.cpu_cluster.cpus.dtb.walker.pwrStateResidencyTicks*
 * *system.cpu_cluster.cpus.dtb.stage2_mmu.stage2_tlb.pwrStateResidencyTicks*
 * *system.cpu_cluster.cpus.itb_walker_cache.pwrStateResidencyTicks*
 * *system.cpu_cluster.cpus.itb_walker_cache.tags.pwrStateResidencyTicks*
 * *system.cpu_cluster.cpus.dtb_walker_cache.pwrStateResidencyTicks*
 * *system.cpu_cluster.cpus.dtb_walker_cache.tags.pwrStateResidencyTicks*
 * *system.cpu_cluster.cpus.dcache.pwrStateResidencyTicks*
 * *system.cpu_cluster.cpus.dcache.tags.pwrStateResidencyTicks*
 * *system.cpu_cluster.cpus.itb.walker.pwrStateResidencyTicks*
 * *system.cpu_cluster.cpus.itb.stage2_mmu.stage2_tlb.pwrStateResidencyTicks*

Αυτές οι παράμετροι έχουν ως σχόλιο *Cumulative time (in ticks) in various power states*, οπότε πρόκειται για συνολικούς χρόνους σε χτύπους ρολογιού για καθένα απ'αυτά τα εξαρτήματα. Έχουν όλα την τιμή 35144000.
 
 Για το *energy* στο αρχείο *stats.txt* βρίσκουμε τις εξής παραμέτρους:
 * *system.mem_ctrls0.rank1.totalEnergy* = 18720000 pJ
 * *system.mem_ctrls0.rank0.totalEnergy* = 19952370 pJ
 * *system.mem_ctrls1.rank1.totalEnergy* = 19011960 pJ
 * *system.mem_ctrls1.rank0.totalEnergy* = 19799535 pJ

Αθροίζοντας τις τιμές αυτές βρίσκουμε συνολική ενέργεια 77483865 pJ για τα memory controls. 
 

#### Ερώτημα 2

#### Ερώτημα 3

### Κριτική

### Πηγές
* Sheng Li, "McPAT: An Integrated Power, Area, and Timing Modeling Framework for Multicore and Manycore Architectures"
* Sheng Li, "McPAT 1.0: An Integrated Power, Area, and Timing Modeling Framework for Multicore Architectures"
* Vasanth Venkatachalam, Michael Franz, "Power Reduction Techniques For Microprocessor Systems"
* Yi-Ping You, "Compilers for Leakage Power Reduction"
* [TAKAKEYA/gem5tomcpat](https://github.com/TAKAKEYA/gem5tomcpat)
